# Вопросы к экзамену

## 1 Вопрос. 
### Хеширование. Полиномиальная хеш-функция. Поиск подстроки в строке при помощи хешей (алгоритм Рабина-Карпа). Оценка времени выполнения.
**Хэширование** - процесс превращения объекта (данных) в хэш - последовательность символов определенной длины, полученная с помощью определенных преобразований.

**Полиномиальная хэш-функция** - хэш-функция, вычисляющая хэш как перевод из p-ной системы счисления в 10-ую:
hash(s)
```rb
p = 131 # простое число, большее мощности алфавита, взаимно простое с mod (опционально вообще простым)
mod = 10**9 + 7 # модуль, по которому выполняются все операции. должно быть большым и взаимно простым с p (опционально вообще простым)

def hash(s):
  n = len(s)
  hash = 0
  for i in range(n):
    hash = (hash * p + ord(s[i])) % mod
return hash
```

**Поиск подстроки в строке при помощи хешей (алгоритм Рабина-Карпа)**
_Идея алгоритма:_ сначала сравниваем подстроку исходной строки с нужной, если хэши равны, то производим посимвольное сравнение
```rb
t = input() 
s = input()
# задача: найти индексы вхождений строки s в строку t
N = len(t)
M = len(s)
hs = hash(s)
ht = hash(s[:M])
for i in range(0, N - M + 1):
  if hs == ht and s[i:i + M] == h:
    print(i)
  if i != N - M: #пересчитываем хэш
    ht = ((ht - ord(t[i]) * p **(M - 1)) * p + ord(t[i + M])) % mod
```
**Оценка времени выполнения:** в лучшем случае О(N) - никакие хэши не равны, в худшем - О(N * M) - все хэши равны, идет проверка всех подстрок

## 2 Вопрос. 
### Z-функция, понятие z-блока. Пи-функция. Определения. Алгоритмы построения. Оценка времени выполнения.
**Z-функция** - функция, возвращающая max длину префикса строки, равного префиксу подстроки s[i::]
**Z-блок** - отрезок с границами l и r включительно, где r - наибольшееотдальение от начала строки, равное len(s[:l:]) + длина префикса, l - индекс элемента с макс отдалением

```rb
def z_func(s):
  N = len(s)
  z = [0] * N
  l, r = 0
  for i in range(1, N):
    ind = 0
    if i <= r:
      ind = min(z[i - l], r - i + 1)
    while ind + i < N and s[ind] == s[i + ind]:
      ind += 1
    if i + ind > r:
      l = i
      r = i + ind - 1
    z[i] = ind

```
**Оценка времени выполнения:** -  в алгоритме мы делаем столько же действий, сколько раз сдвигается правая граница z-блока - О(N)


**Префикс-функция** - функция, возвращающая max длину префикса, равного постфиксу подстроки s[:i]
```rb
def pref_func(s):
  N = len(s)
  p = [0] * (N + 1)
  p[0] = -1
  for i in range(1, N + 1):
    k = p[i - 1]
    while k != -1 and s[k] != s[i - 1]:
      k = p[k]
    p[i] = k + 1
```

**Оценка времени выполнения:** O(N)

**Алгоритм КМП**
_Идея_: склеиваем строки s и t с помощью символа, не встречающегося в этих строках, в строку ans
Тогда вхождения строки s в строку t будет там, где:
+ значение префикс-функции строки ans равно длине s (в этом месте вхождение заканчивается, начинается в ans[i - p[i]]
+ значение z-функции строки ans равно длине s (в этом месте начинается)
**КМП с префикс-функцией**
```rb
l = s + "#" + t
ans = pref_func(l)
for i in range(len(l) + 1):
    if ans[i] == len(s):
        print(i - len(s) - 1 - len(s))
```

**КМП с z-функцией**
```rb
l = s + "#" + t
ans = z_func(l)
for i in range(len(l) + 1):
    if ans[i] == len(s):
        print(i - len(s) - 1)
```

## 3 Вопрос.
### Алгоритм Дейкстры. Постановка задачи, описание алгоритма за O(V^2 + E). Улучшение алгоритма для разреженных графов за O(ElogV).

**Алгоритм Дейкстры** - алгоритм поиска кратчайшего пути в графе от вершины V1 до всех остальных.

**Постановка задачи, описание алгоритма за O(V^2 + E)**
_Суть_: находим вершину curr, от которой расстояние до нужной вершины А наименьшее, для каждого соседа curr сравниваем расстояние до А по прямой и через соседа, находим минимальное.\
Вершину с минимальным расстояние до А делаем curr, если она еще не была такой (если она не посещена)
массив **dist** хранит текущие минимальные расстояния от вершины  до остальных вершин, изначально они равны бесконечности, dist[A] = 0
массив **visited** хранит информацию о посещенных вершинах: 
+ visited[i] = True, если вершина уже была curr (посещена)
+ visited[i] = False, если вершина еще не была curr (не посещена)

```rb
n = int(input())
adj_list = [[] for _ in range(n)]
for i in range(n):
    m = int(input())
    for j in range(m):
        adj_list[i].append(tuple(map(int, input().split())))
        # (номер, вес)

curr = int(input())
dist = [float('inf')] * n
dist[curr] = 0
min_v = curr

visited = [0] * n
count = n

while count > 0:
    for to, weight in adj_list[curr]:
        if not visited[to]:
            if dist[to] > dist[curr] + weight:
                dist[to] = dist[curr] + weight
    visited[curr] = True
    count -= 1
    # ищем новую минимальную вершину
    for i in range(n):
        if min_v == curr or not visited[i] and dist[i] < dist[min_v]:
            min_v = i
    curr = min_v

print(*dist)
```











