# Вопросы к экзамену

## 1 Вопрос. 
### Хеширование. Полиномиальная хеш-функция. Поиск подстроки в строке при помощи хешей (алгоритм Рабина-Карпа). Оценка времени выполнения.
**Хэширование** - процесс превращения объекта (данных) в хэш - последовательность символов определенной длины, полученная с помощью определенных преобразований.

**Полиномиальная хэш-функция** - хэш-функция, вычисляющая хэш как перевод из p-ной системы счисления в 10-ую:
hash(s)
```rb
p = 131 # простое число, большее мощности алфавита, взаимно простое с mod (опционально вообще простым)
mod = 10**9 + 7 # модуль, по которому выполняются все операции. должно быть большым и взаимно простым с p (опционально вообще простым)

def hash(s):
  n = len(s)
  hash = 0
  for i in range(n):
    hash = (hash * p + ord(s[i])) % mod
return hash
```

**Поиск подстроки в строке при помощи хешей (алгоритм Рабина-Карпа)**
_Идея алгоритма:_ сначала сравниваем подстроку исходной строки с нужной, если хэши равны, то производим посимвольное сравнение
```rb
t = input() 
s = input()
# задача: найти индексы вхождений строки s в строку t
N = len(t)
M = len(s)
hs = hash(s)
ht = hash(s[:M])
for i in range(0, N - M + 1):
  if hs == ht and s[i:i + M] == h:
    print(i)
  if i != N - M: #пересчитываем хэш
    ht = ((ht - ord(t[i]) * p **(M - 1)) * p + ord(t[i + M])) % mod
```
**Оценка времени выполнения:** в лучшем случае О(N) - никакие хэши не равны, в худшем - О(N * M) - все хэши равны, идет проверка всех подстрок

## 2 Вопрос. 
### Z-функция, понятие z-блока. Пи-функция. Определения. Алгоритмы построения. Оценка времени выполнения.
**Z-функция** - функция, возвращающая max длину префикса строки, равного префиксу подстроки s[i::]
**Z-блок** - отрезок с границами l и r включительно, где r - наибольшееотдальение от начала строки, равное len(s[:l:]) + длина префикса, l - индекс элемента с макс отдалением

```rb
def z_func(s):
  N = len(s)
  z = [0] * N
  l, r = 0
  for i in range(1, N):
    ind = 0
    if i <= r:
      ind = min(z[i - l], r - i + 1)
    while ind + i < N and s[ind] == s[i + ind]:
      ind += 1
    if i + ind > r:
      l = i
      r = i + ind - 1
    z[i] = ind

```
**Оценка времени выполнения:** -  в алгоритме мы делаем столько же действий, сколько раз сдвигается правая граница z-блока - О(N)


**Префикс-функция** - функция, возвращающая max длину префикса, равного постфиксу подстроки s[:i]
```rb
def pref_func(s):
  N = len(s)
  p = [0] * (N + 1)
  p[0] = -1
  for i in range(1, N + 1):
    k = p[i - 1]
    while k != -1 and s[k] != s[i - 1]:
      k = p[k]
    p[i] = k + 1
```

**Оценка времени выполнения:** O(N)

**Алгоритм КМП**
_Идея_: склеиваем строки s и t с помощью символа, не встречающегося в этих строках, в строку ans
Тогда вхождения строки s в строку t будет там, где:
+ значение префикс-функции строки ans равно длине s (в этом месте вхождение заканчивается, начинается в ans[i - p[i]]
+ значение z-функции строки ans равно длине s (в этом месте начинается)
**КМП с префикс-функцией**
```rb
l = s + "#" + t
ans = pref_func(l)
for i in range(len(l) + 1):
    if ans[i] == len(s):
        print(i - len(s) - 1 - len(s))
```

**КМП с z-функцией**
```rb
l = s + "#" + t
ans = z_func(l)
for i in range(len(l) + 1):
    if ans[i] == len(s):
        print(i - len(s) - 1)
```

